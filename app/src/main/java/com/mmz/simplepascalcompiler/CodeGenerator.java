package com.mmz.simplepascalcompiler;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
public class CodeGenerator {
    //assemblyCode String to hold the string being generated by the CodeGenerator at the end.
    private String assemblyCode;
    //regA variable to hold the current ID being held in the register A(Accumulator).
    private String regA;
    private String dist;
    CodeGenerator(){
        this.assemblyCode="";
        this.regA="";
    }
    //Method 1: Generate the start of the assembly Code program.
    public void startProgram(String progName) {
        assemblyCode = progName + " START 0" + "\nEXTRREF XREAD,XWRITE\nSTL RETADR\n";
    }
    //Method 2: Generate the variables list of the assembly Code program.
    public void defineVariables(ArrayList<String> ids) {
        for (int i = 0; i < ids.size(); i++)
            assemblyCode += ids.get(i) + " RESW 1" + "\n";
    }
    //Method 3: Generate READ source statement of the assembly Code program.
    public void read(ArrayList<String> idsRead) {
        assemblyCode += "+JSUB XREAD" + "\nWORD " + idsRead.size() + "\n";
        for (int i = 0; i < idsRead.size(); i++) {
            assemblyCode += "WORD " + idsRead.get(i) + "\n";
        }
        idsRead.clear();

    }
    //Method 4: Generate WRITE source statement of the assembly Code program.
    public void write(ArrayList<String> idsWrite) {
        assemblyCode += "+JSUB XWRITE" + "\nWORD " + idsWrite.size() + "\n";
        for (int i = 0; i < idsWrite.size(); i++) {
            assemblyCode += "WORD " + idsWrite.get(i) + "\n";
        }
        idsWrite.clear();
    }
    //Method 5: Generate ADD assign source statement of the assembly Code program.
    public void generateAdd(String operand1, String operand2,int counter) {
        if (regA.equals(operand1)) {
            assemblyCode += "ADD " + operand2 + "\n";
            regA = "T" + counter;
        } else if (regA.equals(operand2)) {
            assemblyCode += "ADD " + operand1 + "\n";
            regA = "T" + counter;
        } else {
            if (regA.equals(""))
                assemblyCode += "LDA " + operand1 + "\nADD " + operand2 + "\n";
            else if (!regA.equals(dist))
                assemblyCode += "STA T" + regA.charAt(1) + "\n" + "LDA " + operand1 + "\nADD " + operand2 + "\n";
            else
                assemblyCode += "LDA " + operand1 + "\nADD " + operand2 + "\n";
            regA = "T" + counter;


        }
    }
    //Method 6: Generate MUL assign source statement of the assembly Code program.
    public void generateMul(String operand1, String operand2,int counter){
        if(regA.equals(operand1)){
            assemblyCode += "MUL " + operand2 + "\n";
            regA = "T"+counter;
        }
        else if(regA.equals(operand2)){
            assemblyCode += "MUL " + operand1 + "\n";
            regA = "T"+counter;
        }
        else{
            if(regA.equals(""))
                assemblyCode += "LDA " + operand1 + "\nMUL " + operand2 +"\n";
            else if (!regA.equals(dist))
                assemblyCode += "STA T" + regA.charAt(1) + "\n" + "LDA " + operand1 + "\nMUL " + operand2 + "\n";
            else
                assemblyCode += "LDA " + operand1 + "\nMUL " + operand2 + "\n";
            regA = "T" + counter;
        }
    }
    //Method 7: Generate DIV assign source statement of the assembly Code program.
    public void generateDiv(String operand1, String operand2,int counter){
        if(regA.equals(operand1)){
            assemblyCode += "DIV " + operand2 + "\n";
            regA = "T"+counter;
        }
        else  {
            if(regA.equals(""))
                assemblyCode += "LDA " + operand1 + "\nDIV " + operand2 +"\n";
            else if (!regA.equals(dist))
                assemblyCode += "STA T" + regA.charAt(1) + "\n" + "LDA " + operand1 + "\nDIV " + operand2 + "\n";
            else
                assemblyCode += "LDA " + operand1 + "\nDIV " + operand2 + "\n";
            regA = "T" + counter;
        }
    }
    //Method 8: Generate SUB assign source statement of the assembly Code program.
    public void generateSub(String operand1, String operand2,int counter){
        if(regA.equals(operand1)){
            assemblyCode += "SUB " + operand2 + "\n";
            regA = "T"+counter;
        }
        else  {
            if(regA.equals(""))
                assemblyCode += "LDA " + operand1 + "\nSUB " + operand2 +"\n";
            else if (!regA.equals(dist))
                assemblyCode += "STA T" + regA.charAt(1) + "\n" + "LDA " + operand1 + "\nSUB " + operand2 + "\n";
            else
                assemblyCode += "LDA " + operand1 + "\nSUB " + operand2 + "\n";
            regA = "T" + counter;
        }
    }
    //Method 9: Generate FOR start source statement of the assembly Code program.
    public void generateFor(String start){
        assemblyCode +="LDX "+start+"\nLOOP ";
    }
    //Method 10: Generate FOR end source statement of the assembly Code program.
    public void terminateFor(String end){
        assemblyCode+="TIX "+end+"\nJLT LOOP\n";
    }
    //Method 11 : Stores from register A to destination ID at the end of the assign source statement.
    public void storeDist(String dist){
        regA =dist;
        this.dist=dist;
        assemblyCode += "STA " + dist + "\n";
    }
    //Method 12: Generate the end of the assembly Code program.
    public void end(String progName){
        assemblyCode += "END " + progName;
    }
    //Method 13: Returns the assemblyCode written.
    public String getCode() {
        return assemblyCode;
    }
}
